<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="设计模式"><meta property="og:title" content="设计模式" />
<meta property="og:description" content="题目还原 列举常见的设计模式  什么是设计模式? 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。
什么是 GOF（四人帮，全拼 Gang of Four）？ 在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。
 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。  设计原则 SOLID  单一职责 - 一个类应该只有一个发生变化的原因 开闭原则 - 一个软件实体应当对扩展开发，对修改关闭。 里氏代换原则 - 一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别。 接口隔离原则 - 使用多个专门的接口比使用单一的总接口要好。 依赖倒转原则 - 要依赖与抽象，不要依赖于具体。 迪米特法则 - 一个对象应当对其他对象有尽可能少的了解。 组合、聚合复用原则 - 要尽量使用合成/聚合，尽量不要使用继承。  设计模式类型 创建型 在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。
 简单工厂 工厂 抽象工程 建造者 模板 单例  行为型 在软件工程中， 行为型模式为设计模式的一种类型，用来识别对象之间的常用交流模式并加以实现。如此，可在进行这些交流活动时增强弹性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://iosgua.com/interval/docs/ch09/tc01/9-1-3/" />

<title>设计模式 | 一瓜 iOS 面试小册</title>
<link rel="icon" href="/interval/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/interval/book.min.63f280e0ea25a89c51e2921595679425aa1c3e3011146f41e3436fc7635d7898.css" integrity="sha256-Y/KA4OolqJxR4pIVlWeUJaocPjARFG9B40Nvx2NdeJg=">


<script defer src="/interval/en.search.min.f0cccae7026011e69755f218c2cfa1112991ee21224463ba569ef2af2a423837.js" integrity="sha256-8MzK5wJgEeaXVfIYws&#43;hESmR7iEiRGO6Vp7yrypCODc="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

   <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/interval"><span>一瓜 iOS 面试小册</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>









  <ul>
<li><a href="/interval/">序章</a></li>
<li>第一章 基础知识
<ul>
<li><a href="/interval/docs/ch01/tc01/01/">1.1 计算机网络</a></li>
<li><a href="/interval/docs/ch01/tc02/02/">1.2 操作系统</a></li>
<li><a href="/interval/docs/ch01/tc03/03/">1.3 数据安全</a></li>
<li><a href="/interval/docs/ch01/tc04/04/">1.4 苹果证书</a></li>
</ul>
</li>
<li>第二章 数据结构与算法</li>
<li>第三章 语法特性</li>
<li>第四章 UIKit
<ul>
<li>4.1 基础
<ul>
<li><a href="/interval/docs/ch04/tc01/4-1-1/">什么是事件响应链</a></li>
<li><a href="/interval/docs/ch04/tc01/4-1-2/">什么是离屏渲染</a></li>
<li><a href="/interval/docs/ch04/tc01/4-1-3/">UI 的刷新原理</a></li>
<li><a href="/interval/docs/ch04/tc01/4-1-4/"><code>UIView</code> 和 <code>CALayer</code></a></li>
<li><a href="/interval/docs/ch04/tc01/4-1-5/"><code>layoutsubviews</code></a></li>
</ul>
</li>
<li>4.2 布局方式
<ul>
<li><a href="/interval/docs/ch04/tc02/4-2-1/">AutoLayout 原理与性能</a></li>
</ul>
</li>
<li>4.3 图片
<ul>
<li><a href="/interval/docs/ch04/tc03/4-3-1/">图片解码时机与优化</a></li>
<li><a href="/interval/docs/ch04/tc03/4-3-1/">图片渲染优化</a></li>
<li><a href="/interval/docs/ch04/tc03/4-3-2/">多个相同图片重复加载</a></li>
<li><a href="/interval/docs/ch04/tc03/4-3-3/">imageName</a></li>
</ul>
</li>
</ul>
</li>
<li>第五章 多线程
<ul>
<li>5.1 基础
<ul>
<li><a href="/interval/docs/ch05/tc01/5-1-1/">线程</a></li>
<li><a href="/interval/docs/ch05/tc01/5-1-2/">同步</a></li>
<li><a href="/interval/docs/ch05/tc01/5-1-3/">锁</a></li>
<li><a href="/interval/docs/ch05/tc01/5-1-4/">死锁</a></li>
</ul>
</li>
<li>5.2 GCD
<ul>
<li><a href="/interval/docs/ch05/tc02/5-2-1/">GCD 队列</a></li>
<li><a href="/interval/docs/ch05/tc02/5-2-2/">GCD 线程与队列关系</a></li>
<li><a href="/interval/docs/ch05/tc02/5-2-3/">GCD API</a></li>
<li><a href="/interval/docs/ch05/tc02/5-2-4/"><code>dispatch_once</code> 实现原理</a></li>
</ul>
</li>
<li>5.3 其他
<ul>
<li><a href="/interval/docs/ch05/tc03/5-3-1/"><code>NSOperationQueue</code></a></li>
<li><a href="/interval/docs/ch05/tc03/5-3-2/"><code>NSTimer</code>, <code>CADisplayLink</code>, <code>dispatch_source_t</code></a></li>
</ul>
</li>
</ul>
</li>
<li>第六章 Runtime
<ul>
<li>6.1 结构模型
<ul>
<li><a href="/interval/docs/ch06/tc01/6-1-1/">Runtime 的内存模型</a></li>
<li><a href="/interval/docs/ch06/tc01/6-1-2/"><code>metaclass</code></a></li>
<li><a href="/interval/docs/ch06/tc01/6-1-3/"><code>class_copyIvarList</code></a></li>
<li><a href="/interval/docs/ch06/tc01/6-1-4/"><code>class_rw_t</code></a></li>
<li><a href="/interval/docs/ch06/tc01/6-1-5/">Category</a></li>
<li><a href="/interval/docs/ch06/tc01/6-1-6/">消息转发</a></li>
<li><a href="/interval/docs/ch06/tc01/6-1-7/">方法调用</a></li>
<li><a href="/interval/docs/ch06/tc01/6-1-8/"><code>IMP</code>, <code>SEL</code> 和 <code>Method</code></a></li>
<li><a href="/interval/docs/ch06/tc01/6-1-9/"><code>load</code>, <code>initialize</code></a></li>
</ul>
</li>
<li>6.2 内存管理
<ul>
<li><a href="/interval/docs/ch06/tc02/6-2-1/"><code>weak</code> 弱引用</a></li>
<li><a href="/interval/docs/ch06/tc02/6-2-2/">关联对象</a></li>
<li><a href="/interval/docs/ch06/tc02/6-2-3/">Autoreleasepool</a></li>
<li><a href="/interval/docs/ch06/tc02/6-2-4/">ARC 自动引用计数</a></li>
</ul>
</li>
<li>6.3
<ul>
<li><a href="/interval/docs/ch06/tc03/6-3-1/">Method Swizzle</a></li>
<li><a href="/interval/docs/ch06/tc03/6-3-2/">属性修饰符 <code>atomic</code></a></li>
<li><a href="/interval/docs/ch06/tc03/6-3-3/">iOS 的内省方法</a></li>
<li><a href="/interval/docs/ch06/tc03/6-3-4/"><code>objc_getClass</code></a></li>
</ul>
</li>
</ul>
</li>
<li>第七章 RunLoop和KVO
<ul>
<li>7.1 RunLoop
<ul>
<li><a href="/interval/docs/ch07/tc01/7-1-1/">app如何接收到触摸事件的</a></li>
<li><a href="/interval/docs/ch07/tc02/7-1-2/">为什么只有主线程的runloop是开启的</a></li>
<li><a href="/interval/docs/ch07/tc03/7-1-3/">为什么只在主线程刷新UI</a></li>
<li><a href="/interval/docs/ch07/tc04/7-1-4/">PerformSelector和runloop的关系</a></li>
<li><a href="/interval/docs/ch07/tc05/7-1-5/">如何使线程保活</a></li>
</ul>
</li>
<li><a href="/interval/docs/ch07/tc06/7-2-1/">7.2 KVO</a></li>
</ul>
</li>
<li>第八章 Block
<ul>
<li><a href="/interval/docs/ch08/tc01/8-1-1/">block的内部实现，结构体是什么样的</a></li>
<li><a href="/interval/docs/ch08/tc01/8-1-2/">block是类吗，有哪些类型</a></li>
<li><a href="/interval/docs/ch08/tc01/8-1-3/">一个int变量被 __block 修饰与否的区别？block的变量截获</a></li>
<li><a href="/interval/docs/ch08/tc01/8-1-4/">block在修改NSMutableArray，需不需要添加__block</a></li>
<li><a href="/interval/docs/ch08/tc01/8-1-5/">block怎么进行内存管理的</a></li>
<li><a href="/interval/docs/ch08/tc01/8-1-6/">block可以用strong修饰吗</a></li>
<li><a href="/interval/docs/ch08/tc01/8-1-7/">解决循环引用时为什么要用__strong、__weak修饰</a></li>
<li><a href="/interval/docs/ch08/tc01/8-1-8/">block发生copy时机</a></li>
<li><a href="/interval/docs/ch08/tc01/8-1-9/">Block访问对象类型的auto变量时，在ARC和MRC下有什么区别</a></li>
</ul>
</li>
<li>第九章 工程架构
<ul>
<li>9.1 架构设计
<ul>
<li><a href="/interval/docs/ch09/tc01/9-1-1/">埋点</a></li>
<li><a href="/interval/docs/ch09/tc01/9-1-2/"><code>MVC</code>, <code>MVP</code>, <code>MVVM</code></a></li>
<li><a href="/interval/docs/ch09/tc01/9-1-3/"class=active>设计模式</a></li>
<li><a href="/interval/docs/ch09/tc01/9-1-4/">单例</a></li>
<li><a href="/interval/docs/ch09/tc01/9-1-5/">路由</a></li>
<li><a href="/interval/docs/ch09/tc01/9-1-6/">稳定性</a></li>
<li><a href="/interval/docs/ch09/tc01/9-1-7/">缓存</a></li>
<li><a href="/interval/docs/ch09/tc01/9-1-8/"><code>git diff</code></a></li>
<li><a href="/interval/docs/ch09/tc01/9-1-9/">线程池</a></li>
<li><a href="/interval/docs/ch09/tc01/9-1-10/">APP 架构</a></li>
</ul>
</li>
</ul>
</li>
<li>第十章 性能优化
<ul>
<li>10.1
<ul>
<li><a href="/interval/docs/ch10/tc01/10-1-1/">启动</a></li>
<li><a href="/interval/docs/ch10/tc01/10-1-2/">卡顿</a></li>
<li><a href="/interval/docs/ch10/tc01/10-1-3/">耗电</a></li>
<li><a href="/interval/docs/ch10/tc01/10-1-4/">网络</a></li>
</ul>
</li>
</ul>
</li>
</ul>








</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/interval/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>设计模式</strong>

  <label for="toc-control">
    <img src="/interval/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
<article class="markdown">
  <h1>设计模式</h1><blockquote class="book-hint info">
  <h3 id="题目还原">题目还原</h3>
<p><strong>列举常见的设计模式</strong>
</blockquote>

<h4 id="什么是设计模式">什么是设计模式?</h4>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
<h4 id="什么是-gof四人帮全拼-gang-of-four">什么是 GOF（四人帮，全拼 Gang of Four）？</h4>
<p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>
<ul>
<li>对接口编程而不是对实现编程。</li>
<li>优先使用对象组合而不是继承。</li>
</ul>
<h4 id="设计原则-solid">设计原则 SOLID</h4>
<ul>
<li>单一职责 - 一个类应该只有一个发生变化的原因</li>
<li>开闭原则 - 一个软件实体应当对扩展开发，对修改关闭。</li>
<li>里氏代换原则 - 一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别。</li>
<li>接口隔离原则 - 使用多个专门的接口比使用单一的总接口要好。</li>
<li>依赖倒转原则 - 要依赖与抽象，不要依赖于具体。</li>
<li>迪米特法则 - 一个对象应当对其他对象有尽可能少的了解。</li>
<li>组合、聚合复用原则 - 要尽量使用合成/聚合，尽量不要使用继承。</li>
</ul>
<h4 id="设计模式类型">设计模式类型</h4>
<h4 id="创建型">创建型</h4>
<p>在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。</p>
<ul>
<li>简单工厂</li>
<li>工厂</li>
<li>抽象工程</li>
<li>建造者</li>
<li>模板</li>
<li>单例</li>
</ul>
<h4 id="行为型">行为型</h4>
<p>在软件工程中， 行为型模式为设计模式的一种类型，用来识别对象之间的常用交流模式并加以实现。如此，可在进行这些交流活动时增强弹性。</p>
<ul>
<li>适配者</li>
<li>桥接</li>
<li>组合</li>
<li>装饰者</li>
<li>外观</li>
<li>享元</li>
<li>代理</li>
</ul>
<h4 id="结构型">结构型</h4>
<p>在软件工程中结构型模式是设计模式，借由一以贯之的方式来了解元件间的关系，以简化设计。</p>
<ul>
<li>责任链</li>
<li>命令</li>
<li>迭代者</li>
<li>备忘</li>
<li>观察者</li>
<li>访问者</li>
<li>策略</li>
<li>状态</li>
<li>模板方法</li>
</ul>
<h4 id="常见的设计模式">常见的设计模式</h4>
<ul>
<li>单例模式</li>
<li>工厂模式</li>
<li>观察者模式</li>
<li>响应链模式</li>
<li>策略模式</li>
<li>中间者模式</li>
<li>装饰者模式</li>
</ul>
<h4 id="参考链接">参考链接</h4>
<p><a href="https://github.com/kamranahmedse/design-patterns-for-humans">https://github.com/kamranahmedse/design-patterns-for-humans</a></p>
<h4 id="tips">TIPS</h4>
<p>还有一本书 &laquo;Cocoa设计模式&raquo; 里面有说到Cocoa中使用了哪些设计模式，有兴趣可以看一下。</p>

    <div>
      <a class="flex align-center" href="https://github.com/idevqa/interval-content//edit/master//docs/ch09/tc01/9-1-3.md" target="_blank" rel="noopener">
        <img src="/interval/svg/edit.svg" class="book-icon" alt="Edit" />
        <span>Edit this page</span>
      </a>
    </div>
  
  <hr/>
  <img src="https://raw.githubusercontent.com/Desgard/algo/img/img/_index/wechat-qrcode.png" style="max-width: 100%;"/>
  <p>本作品采用 <strong><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode.zh-Hans">知识署名-非商业性使用-禁止演绎 （BY-NC-ND） 4.0 国际许可协议</a></strong> 进行许可。</p>
</article>
 

      <footer class="book-footer">
        
  <div class="flex justify-between">



</div>

 
        
  
  <div class="book-comments">

</div>
  
 
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












